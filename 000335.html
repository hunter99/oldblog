<html><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />

<title>竹笋炒肉: NetCat的使用</title>

<link rel="stylesheet" href="styles-site.css" tppabs="http://hedong.3322.org/styles-site.css" type="text/css" />
<link rel="alternate" type="application/rss+xml" title="RSS" href="index.rdf.htm" tppabs="http://hedong.3322.org/index.rdf" />

<link rel="start" href="index.htm" tppabs="http://hedong.3322.org/" title="Home" />
<link rel="prev" href="000334.html" tppabs="http://hedong.3322.org/archives/000334.html" title="分布式计算技术" />

<link rel="next" href="000336.html" tppabs="http://hedong.3322.org/archives/000336.html" title="Digester学习笔记(二)" />


<script type="text/javascript" language="javascript">
<!--

function OpenTrackback (c) {
    window.open(c,
                    'trackback',
                    'width=480,height=480,scrollbars=yes,status=yes');
}

var HOST = 'http://hedong.3322.org/archives/hedong.3322.org';

// Copyright (c) 1996-1997 Athenia Associates.
// http://www.webreference.com/js/
// License is granted if and only if this entire
// copyright notice is included. By Tomer Shiran.

function setCookie (name, value, expires, path, domain, secure) {
    var curCookie = name + "=" + escape(value) + ((expires) ? "; expires=" + expires.toGMTString() : "") + ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "") + ((secure) ? "; secure" : "");
    document.cookie = curCookie;
}

function getCookie (name) {
    var prefix = name + '=';
    var c = document.cookie;
    var nullstring = '';
    var cookieStartIndex = c.indexOf(prefix);
    if (cookieStartIndex == -1)
        return nullstring;
    var cookieEndIndex = c.indexOf(";", cookieStartIndex + prefix.length);
    if (cookieEndIndex == -1)
        cookieEndIndex = c.length;
    return unescape(c.substring(cookieStartIndex + prefix.length, cookieEndIndex));
}

function deleteCookie (name, path, domain) {
    if (getCookie(name))
        document.cookie = name + "=" + ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "") + "; expires=Thu, 01-Jan-70 00:00:01 GMT";
}

function fixDate (date) {
    var base = new Date(0);
    var skew = base.getTime();
    if (skew > 0)
        date.setTime(date.getTime() - skew);
}

function rememberMe (f) {
    var now = new Date();
    fixDate(now);
    now.setTime(now.getTime() + 365 * 24 * 60 * 60 * 1000);
    setCookie('mtcmtauth', f.author.value, now, '', HOST, '');
    setCookie('mtcmtmail', f.email.value, now, '', HOST, '');
    setCookie('mtcmthome', f.url.value, now, '', HOST, '');
}

function forgetMe (f) {
    deleteCookie('mtcmtmail', '', HOST);
    deleteCookie('mtcmthome', '', HOST);
    deleteCookie('mtcmtauth', '', HOST);
    f.email.value = '';
    f.author.value = '';
    f.url.value = '';
}

//-->
</script>

<!--
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/"
         xmlns:dc="http://purl.org/dc/elements/1.1/">
<rdf:Description
    rdf:about="http://hedong.3322.org/archives/000335.html"
    trackback:ping="http://hedong.3322.org/mt/mt-tb.cgi/231"
    dc:title="NetCat的使用"
    dc:identifier="http://hedong.3322.org/archives/000335.html"
    dc:subject="ItTech"
    dc:description="　　HttpClient中反复提到用NetCAt进行调试，下载NetCat一看，确实如其所述的小巧而功能强大，如瑞士军刀。 　　NetCat是一个非常简单的Unix工具，可以读、写TCP或UDP网络连接(network connection)。它被设计成一个可靠的后端(back-end)工具，能被其它的程序程序或脚本直接地或容易地驱动。同时，它又是一个功能丰富的网络调试和开发工具，因为它可以建立你可能用到的几乎任何类型的连接，以及一些非常有意思的内建功能。NetCat，它的实际可运行的名字叫nc，应该早很就被提供，就象另一个没有公开但是标准的Unix工具。 　　GNU也有一个netcat项目，但此处学习的不是GNU的那个。..."
    dc:creator="Hilton"
    dc:date="2003-10-25T23:50:44+00:00" />
</rdf:RDF>
-->


<!--
<rdf:RDF xmlns="http://web.resource.org/cc/"
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="http://hedong.3322.org/archives/000335.html">
<dc:title>NetCat的使用</dc:title>
<dc:description>　　HttpClient中反复提到用NetCAt进行调试，下载NetCat一看，确实如其所述的小巧而功能强大，如瑞士军刀。 　　NetCat是一个非常简单的Unix工具，可以读、写TCP或UDP网络连接(network connection)。它被设计成一个可靠的后端(back-end)工具，能被其它的程序程序或脚本直接地或容易地驱动。同时，它又是一个功能丰富的网络调试和开发工具，因为它可以建立你可能用到的几乎任何类型的连接，以及一些非常有意思的内建功能。NetCat，它的实际可运行的名字叫nc，应该早很就被提供，就象另一个没有公开但是标准的Unix工具。 　　GNU也有一个netcat项目，但此处学习的不是GNU的那个。...</dc:description>
<dc:creator>Hilton</dc:creator>
<dc:date>2003-10-25T23:50:44+00:00</dc:date>
<license rdf:resource="http://web.resource.org/cc/PublicDomain" />
</Work>
<License rdf:about="http://web.resource.org/cc/PublicDomain">
<permits rdf:resource="http://web.resource.org/cc/Reproduction" />
<permits rdf:resource="http://web.resource.org/cc/Distribution" />
<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
</License>
</rdf:RDF>
-->


<style>
  .skiplink{display:none};
</style>
</head>

<body>
<div id="skiptocontent"><a class="skiplink" href="#startcontent" accesskey="2">转到主要内容</a></div>
<div id="banner">
<h1><a href="index.htm" tppabs="http://hedong.3322.org/" accesskey="1">竹笋炒肉</a></h1>
<span class="description">东坡有诗“无竹则俗，无肉则C；不俗不C，竹笋炒肉”。：）<br />
欢迎光临的每一位朋友。这是我的第一个BLOG，用来记录我的所学、所做、所思、所想、所经历、所感受。</span>
</div>

<div id="container">

<div class="blog">

<div id="menu">
<a href="000334.html" tppabs="http://hedong.3322.org/archives/000334.html">&laquo; 分布式计算技术</a> |

<a href="index.htm" tppabs="http://hedong.3322.org/">Main</a>
| <a href="000336.html" tppabs="http://hedong.3322.org/archives/000336.html">Digester学习笔记(二) &raquo;</a>

</div>

</div>


<div class="blog">
<h2 class="date">October 25, 2003</h2>

<div class="blogbody">

<h3 id="startcontent" class="title">NetCat的使用</h3>

<p>　　HttpClient中反复提到用<a href="javascript:if(confirm('http://www.atstake.com/research/tools/network_utilities/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.atstake.com/research/tools/network_utilities/'" tppabs="http://www.atstake.com/research/tools/network_utilities/">NetCAt</a>进行调试，下载NetCat一看，确实如其所述的小巧而功能强大，如瑞士军刀。<br />
　　NetCat是一个非常简单的Unix工具，可以读、写TCP或UDP网络连接(network connection)。它被设计成一个可靠的后端(back-end)工具，能被其它的程序程序或脚本直接地或容易地驱动。同时，它又是一个功能丰富的网络调试和开发工具，因为它可以建立你可能用到的几乎任何类型的连接，以及一些非常有意思的内建功能。NetCat，它的实际可运行的名字叫nc，应该早很就被提供，就象另一个没有公开但是标准的Unix工具。<br />
　　GNU也有一个<a href="javascript:if(confirm('http://netcat.sourceforge.net/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://netcat.sourceforge.net/'" tppabs="http://netcat.sourceforge.net/">netcat</a>项目，但此处学习的<ins>不是</ins>GNU的那个。</p>

<a name="more"></a>
<p>　　最简单的使用方法，”nc host port”，能建立一个TCP连接，连向指定的主机和端口。接下来，你的从标准输入中输入的任何内容都会被发送到指定的主机，任何通过连接返回来的信息都被显示在你的标准输出上。这个连接会一直持续下去，至到连接两端的程序关闭连接。注意，这种行为不同于大多数网络程序，它们会在从标准输入读到一个文件结束符后退出。<br />
　　NetCat还可以当服务器使用，监听任意指定端口的连接请求(inbound connection)，并可做同样的读写操作。除了较小限制外，它实际并不关心自己以“客户端”模式还是“服务器”模式运行，它都会来回运送全部数据。在任何一种模式下，都可以设置一个非活动时间来强行关闭连接。<br />
　　它还可以通过UDP来完成这些功能，因此它就象一个telnet那样的UDP程序，用来测试你的UDP服务器。正如它的“U”所指的，UDP跟TCP相比是一种不可靠的数据传输，一些系统在使用UDP传送大量数据时会遇到麻烦，但它还有一些用途。<br />
　　你可能会问“为什么不用telnet来连接任意的端口”？问题提得好(valid)，这儿有一些理由。Telnet有“标准输入文件结束符(standard input EOF)”问题，所以需要在脚本中延迟计算以便等待网络输出结束。这就是netcat持续运行直到连接被关闭的主要原因。Telnet也不能传输任意的二进制数据，因为一些特定的字符会被解释为Telnet的参数而被从数据流中去除。Telnet还将它的一些诊断信息显示到标准输出上，而NetCat会将这信息与它的输出分开以不改变真实数据的传输，除非你要求它这么做。当然了，Telnet也不能监听端口，也不能使用UDP。NetCat没有这些限制，比Telnet更小巧和快捷，而且还有一些其它的功能。<br />
　　NetCat的一些主要功能：<br />
<ol><li>支持连出和连入(outbound and inbound connection)，TCP和UDP，任意源和目的端口</li><br />
<li>全部DNS正向/反向检查，给出恰当的警告</li><br />
<li>使用任何源端口</li><br />
<li>使用任何本地设置的网络资源地址</li><br />
<li>内建端口扫描功能，带有随机数发生器</li><br />
<li>内建loose source-routing功能</li><br />
<li>可能标准输入读取命令行参数</li><br />
<li>慢发送模式，每N秒发送一行</li><br />
<li>以16进制显示传送或接收的数据</li><br />
<li>允许其它程序服务建立连接，可选</li><br />
<li>对Telnet应答，可选</li></ol></p>

<p>编译NetCat<br />
==========<br />
　　编译NetCat是非常简单的。检查一下Makefile，找到符合你的系统类型的SYSTYPE如何拼写,然后运行“make <systype>”，然后可执行的nc就会出现了。如果没有合适的SYSTYPE，用”generic”试试。<br />
　　其Makefile中有dos, ultrix, sunos, solaris-static, solaris, aix, linux, irix, osf, freebsd, bsdi, netbsd, hpux, unixware, aux, next, generic等SYSTYPE，其中generic不算系统类型，则dos其实并不支持。在本文一开始的NetCat的链接页面中，也有一个Windows版本的NetCat，是另一个人做的移植。<br />
　　Linux的sys/time.h并不真正支持FD_SETSIZE的表示，编译时会有一个无害的警告。在一些系统中编译时，可能会与signal()有关的指针类型警告，但不影响编译结果。</p>

<p>开发NetCat的功能<br />
===============<br />
　　NetCat小巧且功能强大，描述它的功能就是象描述瑞士军刀的功能一样。<br />
　　如果没有提供命令行参数，NetCat会提示你从标准输入来输入命令参数，然后NetCat会在内部解析输入。用这种办法输入命令式参数，可以用来防止借助“ps”来查看你的命令行参数。<br />
　　主机参数可以是一个名字或一个IP地址。如果-n出现，则它接受IP地址，而不再对计算机的名字或域名进行解析。如果没有-n，但加上-v，则NetCat可进行正/反向域名解析，并警告the all-too-common problem of mismatched name in DNS。这会耗费稍多一点时间，但在某些情况下会有用处。如，你想知道某个IP的主机名，NetCat可省却你手工查找的时间。<br />
　　要建立对外的连接，必须提供一个端口号，可以是个数字，也可以/etc/services列表中的端口服务名。当-n出现时，则只有数字形式的端口可以接收。<br />
　　-v参数，可以将一些关于连接建立信息输出到标准错误。-v参数多出现几次，则显示的信息会更多一些。如果-v参数没有出现，则NetCat将默默地工作，至到出现错误为止。<br />
　　-w参数后跟一个时间值，用以指定建立链接时的等待时间，-w如果多次出现，则后面的值将取代前面的设置。-w还用来设置连接非活动时间，当标准输入结束以后，如果等待指定的一段时间后仍没有数据返回，则NetCat会再试一次，然后关闭连接并退出。<br />
　　当-u参数出现时，用UDP建立连接。<br />
　　用-o logfile参数，可以将连接上往来传输的数据以16进制的形式记录到logfile中（每行的左半部分是16进制显示，右半部分为ascii显示）。其中，每行的第一个字符为”<”或”>”，分别表示接收的数据或发送的数据。<br />
　　NetCat用-s ip-addr或-s name来绑定本地网络资源地址，-p portarg来绑定本地端口。除了因权限限制或端口已经使用外，-p可以绑定任何端口。Root用户可以绑定保留的1024以内的端口。如果不用-p指定端口，则使用系统给定的未使用的端口。(-p功能在客户端状态也可以使用,-s功能并不是在所有的平台上都可用)<br />
　　-l参数可以使NetCat以服务器状态运行。”nc -l -p 1234<file”会使NetCat监听1234端口，且一旦有连接接入，则将file的内容发送出去，不管对方想不想要(有点象远程登录时显示的欢迎信息)。”nc -l -p <bindingport> [remote hostname] [remote port]”可以用来指定入连的主机和端口，如果申请连接的主机或端口不符指定，则会断开连接。<br />
　　当编译时置-DGAPING_SECURITY_HOLE，则-e参数被NetCat支持。-e后面跟一可执行程序的名称，当一个连接（入或出）被建立时，这个程序被运行。尤其当NetCat以服务器端运行时，-e参数使其有点象inetd了，只是只能运行一个进行而已。需要说明的是，-e后的程序不能从NetCat的命令行接收参数，如果有参数要传递，可能需要一个脚本。<br />
　　当编译时置-DTELNET，则-t参数被支持，此时NetCat可以登录到一个telnetd服务器，并提供相关的握手应答，至到出现登录提示符。<br />
　　NetCat用8k的读写，来尽可能高效将收到数据显示到标准输出上及将标准输入写到连接上。-i参数，可以用来设置发送一行标准输入信息的间隔，以减少发送速度。<br />
　　端口扫描是一探测主机服务的流行方法。NetCat的命令行中，先是参数，再是主机，最后是端口。端口可以是一些服务名、端口号，或者是一个端口范围（形如N-M）。”nc -v -w 2 -z -i 1 <target> 20-30”用来扫描target主机的20-30(两端包含)端口，-z表示不发送任何数据到TCP连接或非常有限的数据到UDP连接。-i用以指明两个端口建立连接的时间的间隔。-w用以指明连接不活动时间。通常情况下，扫描按从高到低的顺序依次扫描指定的端口，-r参数可以让NetCat在指定的端口范围内随机地扫描端口。（当-r被用于单个连接时，本地的端口在8192以上，除非用-p指定)<br />
　　-g可以用来指定网关（最多可达8个），-G可以用来指定source-routing pointer。(这是原文，但我还是不明白。：（-g => Group hops <br />
Many people are interested in testing network connectivity using IP source routing, even if it's only to make sure their own firewalls are blocking source-routed packets. On systems that support it, the -g switch can be used multiple times [up to 8] to construct a loose-source-routed path for your connection, and the -G argument positions the ``hop pointer'' within the list. If your network allows source-routed traffic in and out, you can test connectivity to your own services via remote points in the internet. Note that although newer BSD-flavor telnets also have source-routing capability, it isn't clearly documented and the command syntax is somewhat clumsy. Netcat's handling of ``-g'' is modeled after ``traceroute''.）<br />
　　NetCat不是一个任意包发生器，但可以与raw socket通话，nit/bpf/dlpi有时也能行( nit/bpf/dlpi may appear at some point).推荐Drren Reed的ip_filter包，里面有一个工具能创建并发送raw packets.<br />
　　记到最后，越来越感觉到这个东东不简单，而且一旦为牛人所用，威力更是无比。上网一搜，果然一有名的工具。：（在NetCat说明的最后，有许多的例子和探讨，却是不敢写在这儿了。<br />
</p>

<span class="posted">Posted by Hilton at October 25, 2003 11:50 PM
| <a href="mt-tb.cgi-__mode=view&entry_id=335.htm" tppabs="http://hedong.3322.org/mt/mt-tb.cgi?__mode=view&entry_id=335" onclick="OpenTrackback(this.href); return false">TrackBack</a>

<br /></span>

</div>


<div class="comments-head"><a name="comments"></a>Comments</div>

<div class="comments-body">
<p>不客气.我也是个初学者,学习就是个交流的过程:)<br />
不知什么原因,最后的一部分居然没加上,我说怎么看着不对劲:(</p>

<p>四.ftp服务器<br />
nc可以从任何地方接受输入,不仅仅是-e指定的程序,还可以是文件;nc可以将输入重定向到任何地方,不仅仅是默认的屏幕.指定的方法很简单,使用 > 和 somefile<br />
例2; server: nc -l -c -p 1234 >somefile<br />
     client: nc 192.168.0.1 1234 /check/host.disk1<br />
然后,可以利用linux内核的loopback特性,把host.disk以只读的方式mount上,然后就可以做取证分析了.<br />
[如果真的做取证分析,一定不要在原始的受害主机硬盘上find和类似的操作,因为这会修改时间标记而破坏原始的证据]</p>

<p><br />
例4. 将文件压缩后再传送.<br />
如果你的文件很大,何不先压缩它呢,利用管道,我们甚至不用生成压缩后的中间文件!<br />
源主机: tar czf - work|nc -l -c -p 1234 <br />
目的主机: nc 192.168.0.1 1234|tar xzvf -</p>

<p>[tar打包时最好不要使用绝对路径,虽然GNU的tar能把它转换成相对路径,但不是所有的平台都能做到,所以如果不想把你的文件系统搞乱的话,就使用相对路径吧!]</p>

<p><br />
…………</p>

<p>这里的server和client的组合是可以互换的，以第六节中例1来说明：<br />
你也可以这样：<br />
干净主机： nc -l -p 1234 -c |md5sum -c -|grep -v OK<br />
被入侵主机：find /etc -type f|xargs md5sum|nc 192.168.0.2 1234</p>

<p>其实，这些都不是固定的程式，根据你的实际需要，你可以想出更多的使用方法。因为，你是在使用UNIX,这就是UNIX。<br />
that's all.抛砖引玉,写到这里吧,这就是"瑞士军刀",觉得怎么样?其实netcat还有许多许多其他的用法,唯一限制就是你的想象力,把你知道的告诉我,OK?</p>

<p>当然还有些方面我没有写出来,比如,netcat中继的问题.某些黑客就拿netcat中继功能用做跳板来躲避追踪的<br />
这方面没有怎么研究过,再者也没有时间,如果哪位高手知道,请告诉我. :)</p>
<span class="comments-post">Posted by: <a href="javascript:if(confirm('http://hedong.3322.org/archives/mailto&  \n\nThis file was not retrieved by Teleport Pro, because the server reports that this file cannot be found.  \n\nDo you want to open it from the server?'))window.location='http://hedong.3322.org/archives/mailto&#58;linxd&#64;peoplemail&#46;com&#46;cn'" tppabs="http://hedong.3322.org/archives/mailto&#58;linxd&#64;peoplemail&#46;com&#46;cn">linxd</a> at December 12, 2003 08:22 AM</span>
</div>
<div class="comments-body">
<p>　　非常感谢linxd的文字。<br />
　　同样是这么一个程序，在不同的人手中，发挥的功能就差别很大。从你的文字中，我学到了很多。谢谢！</p>

<p>Hilton</p>
<span class="comments-post">Posted by: <a href="index.htm" tppabs="http://hedong.3322.org/">Hilton</a> at December 11, 2003 09:53 PM</span>
</div>
<div class="comments-body">
<p>有关netcat的文章实在是太多了,关于它的强大我就不再复述了.<br />
netcat可以作为类似于telent的客户端,也可以监听某个端口作为服务器,还可以作为扫描工具扫描对方主机的端口,还可以用来传输文件,不相信吗?听我慢慢道来:)<br />
首先我们要弄明白netcat的工作原理,其实netcat的原理很简单,它就是从网络的一端读入数据,然后输出到网络的另一端,它可以使用tcp和udp协议.之所以叫做netcat,因为它是网络上的cat,想象一下cat的功能,读出一个文件的内容,然后输出到屏幕上(默认的stdout是屏幕,当然可以重定向到其他地方).netcat也是如此,它读取一端的输入,然后传送到网络的另一端,<br />
就这么简单.但是千万不要小看了它,netcat可以完成很多任务,,尤其是和其他程序组合时.好了,废话少说,进入正题吧.:p <br />
网上有两种版本的netcat,一个是@stake公司的netcat,<a href="javascript:if(confirm('http://www.atstake.com/research/tools/network_utilities/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.atstake.com/research/tools/network_utilities/'" tppabs="http://www.atstake.com/research/tools/network_utilities/">http://www.atstake.com/research/tools/network_utilities/</a> 也就是最初的版本,还有一个是GNU的netcat.<a href="javascript:if(confirm('http://netcat.sourceforge.net/download.php  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://netcat.sourceforge.net/download.php'" tppabs="http://netcat.sourceforge.net/download.php">http://netcat.sourceforge.net/download.php</a> 我个人更倾向于使用GNU的netcat,因为它的功能更多,不过GNU的没有windows平台的版本:confused: <br />
至于编译和安装我想就不用说了,如果这关都过不了,我想也有点太……，看看readme和install文件，一般情况下./configure&&make&&make install就ok了，具体的./configure选项看看帮助。</p>

<p>netcat的命令行程序名字为nc,是netcat的缩写,安装完了是找不到netcat这个程序的.:)</p>

<p>root@mail etc #nc -h<br />
GNU netcat 0.7.0, a rewrite of the famous networking tool.<br />
Basic usages:<br />
connect to somewhere:  nc [options] hostname port [port] ...<br />
listen for inbound:    nc -l -p port [options] [hostname] [port] ...<br />
tunnel to somewhere:   nc -L hostname:port -p port [options]</p>

<p>Mandatory arguments to long options are mandatory for short options too.<br />
Options:<br />
  -c, --close                close connection on EOF from stdin<br />
  -e, --exec=PROGRAM         program to exec after connect<br />
  -g, --gateway=LIST         source-routing hop point[s], up to 8<br />
  -G, --pointer=NUM          source-routing pointer: 4, 8, 12, ...<br />
  -h, --help                 display this help and exit<br />
  -i, --interval=SECS        delay interval for lines sent, ports scanned<br />
  -l, --listen               listen mode, for inbound connects<br />
  -L, --tunnel=ADDRESS:PORT  forward local port to remote address<br />
  -n, --dont-resolve         numeric-only IP addresses, no DNS<br />
  -o, --output=FILE          output hexdump traffic to FILE (implies -x)<br />
  -p, --local-port=NUM       local port number<br />
  -r, --randomize            randomize local and remote ports<br />
  -s, --source=ADDRESS       local source address (ip or hostname)<br />
  -t, --tcp                  TCP mode (default)<br />
  -T, --telnet               answer using TELNET negotiation<br />
  -u, --udp                  UDP mode<br />
  -v, --verbose              verbose (use twice to be more verbose)<br />
  -V, --version              output version information and exit<br />
  -x, --hexdump              hexdump incoming and outgoing traffic<br />
  -w, --wait=SECS            timeout for connects and final net reads<br />
  -z, --zero                 zero-I/O mode (used for scanning)</p>

<p>Remote port number can also be specified as range.  Example: '1-1024'</p>

<p>我用的是GNU的netcat,比起@stake公司的netcat多了-c选项,不过这是很有用的一个选项,后面我们会讲到.还有GNU的-L,-t ,-T选项和@stake的-L -t用途是不一样的,自己琢磨吧.</p>

<p>一.客户端<br />
这是最简单的使用方式,nc  <br />
nc www.apache.org 80<br />
get / http/1.1<br />
HTTP/1.1 400 Bad Request<br />
Date: Mon, 08 Dec 2003 06:23:31 GMT<br />
Server: Apache/2.0.48-dev (Unix)<br />
Content-Length: 310<br />
Connection: close<br />
Content-Type: text/html; charset=iso-8859-1</p>

<p></p>

<p>400 Bad Request</p>

<p>Bad Request<br />
Your browser sent a request that this server could not understand.</p>

<p><br />
Apache/2.0.48-dev (Unix) Server at www.apache.org Port 80</p>

<p>呵呵,看到了什么,我什么也没说哦:p</p>

<p>二.简单服务器<br />
nc -l -p  //这里-l参数表明nc处于监听模式,-p指定端口号.<br />
nc -l -p 1234[假设这台主机ip为192.168.0.1]<br />
然后从客户端输入,nc 192.168.0.1 1234 然后你从任一端输入的数据就会显示在另一端了.其实netcat的server和client的区别并不大,区别仅仅在于谁执行了-l来监听端口,一旦连接建立以后,就没有什么区别了.从这里我们也可以了解netcat的工作原理了,通过网络链接读写数据.[It is a simple Unix utility which reads and writes data across network connections, using TCP or UDP protocol]--@stake主页是这么说的.</p>

<p>三.telnet服务器<br />
nc有一个-e的选项,用来指定在连接后执行的程序.<br />
在windows平台上可以指定-e cmd.exe[winxp,win2000,]如果是98就指定command.exe.linux则指定-e bash,或者任何你喜欢的shell,或者是你自己编写的程序,通常是做为后门:p<br />
指定-e的效果是由你指定的程序代替了nc自己来接受另一端的输入,并把输入(命令)后反馈的结果显示到另一端.<br />
server: nc -l -p 1234 -e bash<br />
client: nc 192.168.0.1 1234 就可以远程登陆server了<br />
其实我们不一定非要在server端指定-e,也可以在client端指定.<br />
server: nc -l -p 1234<br />
client: nc -e 192.168.0.1 1234 .这样,就相当于在server上远程登陆client了.我前面说过,有关client和server的区分是没有什么意义的.谁做为telnet server的标准只有一个,谁执行了-e [shell].</p>

<p>四.ftp服务器<br />
nc可以从任何地方接受输入,不仅仅是-e指定的程序,还可以是文件;nc可以将输入重定向到任何地方,不仅仅是默认的屏幕.指定的方法很简单,使用 > 和 somefile<br />
例2; server: nc -l -c -p 1234 >somefile<br />
     client: nc 192.168.0.1 1234 /check/host.disk1<br />
然后,可以利用linux内核的loopback特性,把host.disk以只读的方式mount上,然后就可以做取证分析了.<br />
[如果真的做取证分析,一定不要在原始的受害主机硬盘上find和类似的操作,因为这会修改时间标记而破坏原始的证据]</p>

<p><br />
例4. 将文件压缩后再传送.<br />
如果你的文件很大,何不先压缩它呢,利用管道,我们甚至不用生成压缩后的中间文件!<br />
源主机: tar czf - work|nc -l -c -p 1234 <br />
目的主机: nc 192.168.0.1 1234|tar xzvf -</p>

<p>[tar打包时最好不要使用绝对路径,虽然GNU的tar能把它转换成相对路径,但不是所有的平台都能做到,所以如果不想把你的文件系统搞乱的话,就使用相对路径吧!]</p>

<p><br />
…………</p>

<p>这里的server和client的组合是可以互换的，以第六节中例1来说明：<br />
你也可以这样：<br />
干净主机： nc -l -p 1234 -c |md5sum -c -|grep -v OK<br />
被入侵主机：find /etc -type f|xargs md5sum|nc 192.168.0.2 1234</p>

<p>其实，这些都不是固定的程式，根据你的实际需要，你可以想出更多的使用方法。因为，你是在使用UNIX,这就是UNIX。<br />
that's all.抛砖引玉,写到这里吧,这就是"瑞士军刀",觉得怎么样?其实netcat还有许多许多其他的用法,唯一限制就是你的想象力,把你知道的告诉我,OK?</p>

<p>当然还有些方面我没有写出来,比如,netcat中继的问题.某些黑客就拿netcat中继功能用做跳板来躲避追踪的<br />
这方面没有怎么研究过,再者也没有时间,如果哪位高手知道,请告诉我. :)</p>
<span class="comments-post">Posted by: <a href="javascript:if(confirm('http://hedong.3322.org/archives/mailto&  \n\nThis file was not retrieved by Teleport Pro, because the server reports that this file cannot be found.  \n\nDo you want to open it from the server?'))window.location='http://hedong.3322.org/archives/mailto&#58;linxd&#64;peoplemail&#46;com&#46;cn'" tppabs="http://hedong.3322.org/archives/mailto&#58;linxd&#64;peoplemail&#46;com&#46;cn">linxd</a> at December 11, 2003 01:24 PM</span>
</div>



<div class="comments-head">Post a comment</div>

<div class="comments-body">
<form method="post" action="http://hedong.3322.org/mt/mt-comments.cgi" name="comments_form" onsubmit="if (this.bakecookie[0].checked) rememberMe(this)">
<input type="hidden" name="static" value="1" />
<input type="hidden" name="entry_id" value="335" />

<div style="width:180px; padding-right:15px; margin-right:15px; float:left; text-align:left; border-right:1px dotted #bbb;">
	<label for="author">Name:</label><br />
	<input tabindex="1" id="author" name="author" /><br /><br />

	<label for="email">Email Address:</label><br />
	<input tabindex="2" id="email" name="email" /><br /><br />

	<label for="url">URL:</label><br />
	<input tabindex="3" id="url" name="url" /><br /><br />
</div>

Remember personal info?<br />
<input type="radio" id="bakecookie" name="bakecookie" /><label for="bakecookie">Yes</label><input type="radio" id="forget" name="bakecookie" onclick="forgetMe(this.form)" value="Forget Info" style="margin-left: 15px;" /><label for="forget">No</label><br style="clear: both;" />

<label for="text">Comments:</label><br />
<textarea tabindex="4" id="text" name="text" rows="10" cols="50"></textarea><br /><br />

<input type="submit" name="preview" value="&nbsp;Preview&nbsp;" />
<input style="font-weight: bold;" type="submit" name="post" value="&nbsp;Post&nbsp;" /><br /><br />

</form>

<script type="text/javascript" language="javascript">
<!--
document.comments_form.email.value = getCookie("mtcmtmail");
document.comments_form.author.value = getCookie("mtcmtauth");
document.comments_form.url.value = getCookie("mtcmthome");
if (getCookie("mtcmtauth")) {
    document.comments_form.bakecookie[0].checked = true;
} else {
    document.comments_form.bakecookie[1].checked = true;
}
//-->
</script>
</div>


</div>
</div>
</body>
</html>
	
