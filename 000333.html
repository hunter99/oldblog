<html><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />

<title>竹笋炒肉: Digester学习笔记(一)</title>

<link rel="stylesheet" href="styles-site.css" tppabs="http://hedong.3322.org/styles-site.css" type="text/css" />
<link rel="alternate" type="application/rss+xml" title="RSS" href="index.rdf.htm" tppabs="http://hedong.3322.org/index.rdf" />

<link rel="start" href="index.htm" tppabs="http://hedong.3322.org/" title="Home" />
<link rel="prev" href="000332.html" tppabs="http://hedong.3322.org/archives/000332.html" title="HttpClient学习（五）" />

<link rel="next" href="000334.html" tppabs="http://hedong.3322.org/archives/000334.html" title="分布式计算技术" />


<script type="text/javascript" language="javascript">
<!--

function OpenTrackback (c) {
    window.open(c,
                    'trackback',
                    'width=480,height=480,scrollbars=yes,status=yes');
}

var HOST = 'http://hedong.3322.org/archives/hedong.3322.org';

// Copyright (c) 1996-1997 Athenia Associates.
// http://www.webreference.com/js/
// License is granted if and only if this entire
// copyright notice is included. By Tomer Shiran.

function setCookie (name, value, expires, path, domain, secure) {
    var curCookie = name + "=" + escape(value) + ((expires) ? "; expires=" + expires.toGMTString() : "") + ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "") + ((secure) ? "; secure" : "");
    document.cookie = curCookie;
}

function getCookie (name) {
    var prefix = name + '=';
    var c = document.cookie;
    var nullstring = '';
    var cookieStartIndex = c.indexOf(prefix);
    if (cookieStartIndex == -1)
        return nullstring;
    var cookieEndIndex = c.indexOf(";", cookieStartIndex + prefix.length);
    if (cookieEndIndex == -1)
        cookieEndIndex = c.length;
    return unescape(c.substring(cookieStartIndex + prefix.length, cookieEndIndex));
}

function deleteCookie (name, path, domain) {
    if (getCookie(name))
        document.cookie = name + "=" + ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "") + "; expires=Thu, 01-Jan-70 00:00:01 GMT";
}

function fixDate (date) {
    var base = new Date(0);
    var skew = base.getTime();
    if (skew > 0)
        date.setTime(date.getTime() - skew);
}

function rememberMe (f) {
    var now = new Date();
    fixDate(now);
    now.setTime(now.getTime() + 365 * 24 * 60 * 60 * 1000);
    setCookie('mtcmtauth', f.author.value, now, '', HOST, '');
    setCookie('mtcmtmail', f.email.value, now, '', HOST, '');
    setCookie('mtcmthome', f.url.value, now, '', HOST, '');
}

function forgetMe (f) {
    deleteCookie('mtcmtmail', '', HOST);
    deleteCookie('mtcmthome', '', HOST);
    deleteCookie('mtcmtauth', '', HOST);
    f.email.value = '';
    f.author.value = '';
    f.url.value = '';
}

//-->
</script>

<!--
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/"
         xmlns:dc="http://purl.org/dc/elements/1.1/">
<rdf:Description
    rdf:about="http://hedong.3322.org/archives/000333.html"
    trackback:ping="http://hedong.3322.org/mt/mt-tb.cgi/229"
    dc:title="Digester学习笔记(一)"
    dc:identifier="http://hedong.3322.org/archives/000333.html"
    dc:subject="ItTech"
    dc:description="　　在windows下开发程序，用M$提供的接口处理.ini文件或管理注册表的键值是非常方便的。在java平台上开发程序，则习惯于以xml格式的文件来存放系统的配置信息，对这种文件的解析和处理，可以用sax或dom。有没有更简便的方法呢？有，就是用digester模块。 　　Digester是Jakarta 子项目Commons下的一个模块，支持基于规则的对任意XML文档的处理。它最初是Structs项目的一部分，后因其通用性而划归Commons...."
    dc:creator="Hilton"
    dc:date="2003-10-23T23:26:41+00:00" />
</rdf:RDF>
-->


<!--
<rdf:RDF xmlns="http://web.resource.org/cc/"
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="http://hedong.3322.org/archives/000333.html">
<dc:title>Digester学习笔记(一)</dc:title>
<dc:description>　　在windows下开发程序，用M$提供的接口处理.ini文件或管理注册表的键值是非常方便的。在java平台上开发程序，则习惯于以xml格式的文件来存放系统的配置信息，对这种文件的解析和处理，可以用sax或dom。有没有更简便的方法呢？有，就是用digester模块。 　　Digester是Jakarta 子项目Commons下的一个模块，支持基于规则的对任意XML文档的处理。它最初是Structs项目的一部分，后因其通用性而划归Commons....</dc:description>
<dc:creator>Hilton</dc:creator>
<dc:date>2003-10-23T23:26:41+00:00</dc:date>
<license rdf:resource="http://web.resource.org/cc/PublicDomain" />
</Work>
<License rdf:about="http://web.resource.org/cc/PublicDomain">
<permits rdf:resource="http://web.resource.org/cc/Reproduction" />
<permits rdf:resource="http://web.resource.org/cc/Distribution" />
<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
</License>
</rdf:RDF>
-->


<style>
  .skiplink{display:none};
</style>
</head>

<body>
<div id="skiptocontent"><a class="skiplink" href="#startcontent" accesskey="2">转到主要内容</a></div>
<div id="banner">
<h1><a href="index.htm" tppabs="http://hedong.3322.org/" accesskey="1">竹笋炒肉</a></h1>
<span class="description">东坡有诗“无竹则俗，无肉则C；不俗不C，竹笋炒肉”。：）<br />
欢迎光临的每一位朋友。这是我的第一个BLOG，用来记录我的所学、所做、所思、所想、所经历、所感受。</span>
</div>

<div id="container">

<div class="blog">

<div id="menu">
<a href="000332.html" tppabs="http://hedong.3322.org/archives/000332.html">&laquo; HttpClient学习（五）</a> |

<a href="index.htm" tppabs="http://hedong.3322.org/">Main</a>
| <a href="000334.html" tppabs="http://hedong.3322.org/archives/000334.html">分布式计算技术 &raquo;</a>

</div>

</div>


<div class="blog">
<h2 class="date">October 23, 2003</h2>

<div class="blogbody">

<h3 id="startcontent" class="title">Digester学习笔记(一)</h3>

<p>　　在windows下开发程序，用M$提供的接口处理.ini文件或管理注册表的键值是非常方便的。在java平台上开发程序，则习惯于以xml格式的文件来存放系统的配置信息，对这种文件的解析和处理，可以用sax或dom。有没有更简便的方法呢？有，就是用digester模块。<br />
　　Digester是Jakarta 子项目Commons下的一个模块，支持基于规则的对任意XML文档的处理。它最初是Structs项目的一部分，后因其通用性而划归Commons.<br />
</p>

<a name="more"></a>
<p><h4>下载及编译</h4><div class="code">cvs -d :pserver:anoncvs@cvs.apache.org:/home/cvspublic login<br />
password: anoncvs<br />
cvs -d :pserver:anoncvs@cvs.apache.org:/home/cvspublic checkout jakarta-commons/digester<br />
cd jakarta-commons/digester<br />
ant dist<br />
</div><br />
　　Digester的运行依赖下列包：<br />
<ol><li>一个遵循Jaxp(1.1版本及以后)的XML解析器</li><br />
<li>Jakarta commons beanutils包(1.5版本及以后)</li><br />
<li>Jakarta commons collections包(2.1版本及以后)</li><br />
<li>Jakarta commons logging包(1.0.2版本及以后)</li></ol>　<br />
<h4>一个简单的例子</h4>　　假定有两个JavaBean如下，分别为Foo和Bar<br />
<div class="code">package mypackage;<br />
public class Foo {<br />
&nbsp;&nbsp;public void addBar(Bar bar);<br />
&nbsp;&nbsp;public Bar findBar(int id);<br />
&nbsp;&nbsp;public Iterator getBars();<br />
&nbsp;&nbsp;public String getName();<br />
&nbsp;&nbsp;public void setName(String name);<br />
}<br />
public mypackage;<br />
public class Bar {<br />
&nbsp;&nbsp;public int getId();<br />
&nbsp;&nbsp;public void setId(int id);<br />
&nbsp;&nbsp;public String getTitle();<br />
&nbsp;&nbsp;public void setTitle(String title);<br />
}</div><br />
　　用下面的xml文件进行配置<br />
<div class="code">&lt;foo name="The Parent"&gt;<br />
&nbsp;&nbsp;&lt;bar id="123" title="The First Child"/&gt;<br />
&nbsp;&nbsp;&lt;bar id="456" title="The Second Child"/&gt;<br />
&lt;/foo&gt;</div><br />
　　用下面几行代码即可完成配置文件解析工作：<br />
<table border="1"><tr><td>Digest解析代码</td><td>注释</td></tr><tr><td>Digester digester = new Digester();</td><td></td></tr><tr><td>digester.setValidating(false);</td><td>不进行XML与相应的DTD的合法性验证</td></tr><tr><td>digester.addObjectCreate("foo", "mypackage.Foo");</td><td>当遇到&lt;foo&gt;时创建一个mypackage.Foo对象，并将其放在栈顶</td></tr><tr><td>digester.addSetProperties("foo");</td><td>根据&lt;foo&gt;元素的属性(attribute)，对刚创建的Foo对象的属性(property)进行设置</td></tr><tr><td>digester.addObjectCreate("foo/bar", "mypackage.Bar");</td><td>当遇到&lt;foo&gt;的子元素&lt;bar&gt;时创建一个mypackage.Bar对象，并将其放在栈顶。</td></tr><tr><td>digester.addSetProperties("foo/bar");</td><td>根据&lt;bar&gt;元素的属性(attribute)，对刚创建的Bar对象的属性(property)进行设置</td></tr><tr><td>digester.addSetNext("foo/bar", "addBar", "mypackage.Bar");</td><td>当再次遇到&lt;foo&gt;的子元素&lt;bar&gt;时创建一个mypackage.Bar对象，并将其放在栈顶，同时调用第二栈顶元素(Foo对象)的addBar方法。</td></tr><tr><td>Foo foo = (Foo) digester.parse();</td><td>分析结束后，返回根元素。</td></tr></table><br />
<h4>基本情况</h4>　　熟悉用SAX来处理XML文档的程序员，会发现Digester隐藏了遍历XML元素这些细节，而是提供了更高一层的、更友好的SAX事件接口，从而让程序员的精力放在对数据的处理过程中。<br />
　　使用Digester，须按照以下步骤：<br />
<ol><li>创建一个org.apache.commons.digester.Digester实例。一个解析请求完成后，这个Digester可以被后面复用。但也不要试图在不同的线程中从共享一个Digester实例。</li><br />
<li>根据需要设置一些配置属性(configuration properties)，以控制下一步的解析操作。</li><br />
<li>将一个或几个初始对象(initial object)压入Digester对象栈,本步骤不是必须的。</li><br />
<li>注册所有的元素匹配模板(elemet matching pattern)。当一个模板被从输入文档中识别出来以后，与其相联系的处理规则(processing rules)被激活。对一个特定的模板，可以定义任意多的规则，当识别出该模板后，这些规则依序依次执行。</li><br />
<li>调用digester.parse()方法，一个XML文档的引用(用多种方式供选择)要传给这个方法。注意，需要捕捉并处理IOException或SAXEception或处理过程中抛出的异常。</li></ol><br />
<h4>元素匹配模板</h4>　　Digester能自动遍历目标XML文档的元素形成的层次结构，这个过程无需程序员参与。程序员的任务是决定，在解析的过程中，当由嵌套的元素形成的一个特定序列被识别出时，如何处理它。用以描述这种序列的机制，就叫“元素匹配模板”。<br />
　　具体说来，元素和其子元素间，用”/”相隔，如果一些元素前没有”/”则其必为根元素。如例：<br />
<div class="code">&lt;a&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;匹配模板&nbsp;"a"<br />
&nbsp;&nbsp;&lt;b&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;匹配模板&nbsp;"a/b"<br />
&nbsp;&nbsp;&nbsp;&nbsp;&lt;c/&gt;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;匹配模板&nbsp;"a/b/c"<br />
&nbsp;&nbsp;&nbsp;&nbsp;&lt;c/&gt;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;匹配模板&nbsp;"a/b/c"<br />
&nbsp;&nbsp;&lt;/b&gt;<br />
&nbsp;&nbsp;&lt;b&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;匹配模板&nbsp;"a/b"<br />
&nbsp;&nbsp;&nbsp;&nbsp;&lt;c/&gt;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;匹配模板&nbsp;"a/b/c"<br />
&nbsp;&nbsp;&nbsp;&nbsp;&lt;c/&gt;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;匹配模板&nbsp;"a/b/c"<br />
&nbsp;&nbsp;&nbsp;&nbsp;&lt;c/&gt;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;匹配模板&nbsp;"a/b/c"<br />
&nbsp;&nbsp;&lt;/b&gt;<br />
&lt;/a&gt;</div><br />
　　字符”*”表示任意级别，如”*/a”表示任意级别的&lt;a&gt;都可匹配(不包括根元素级的).熟悉XLST的朋友，对这种思路一定不陌生。<br />
　　从上面的描述，可知某个元素同时满足多个匹配模板是非常可能的，在这种情况下，与各个模板相关联的处理规则（processing rule）的执行顺序如下：对begin或body方法，按照各个rule的注册顺序的先后，对end方法则是注册顺序的反序。<br />
<h4>处理规则(processing rule)</h4>　　元素匹配模板用以识别什么时候采取行动，处理规则则用以定义行动的内容。<br />
　　从形式上讲，一个处理规则是一个java类，它扩展了org.apache.commons.digester.Rule类。每个处理规则，实现下列的一个或几个事件处理方法(event method)，当相应的模板匹配成功以后，在已定义的某个时刻，这些事件方法会被触发。<br />
<ol><li>begin(),在一个匹配元素被识别出后的“开始”时刻被调用，这个元素的所有属性放在一个数据结构中被传递给begin()</li><br />
<li>body(),当元素的嵌套内容（如子元素）被识别出时被调用。在解析的过程中，前后的空白被去掉了</li><br />
<li>end(),匹配元素的“结束”时刻被调用。如果子元素也匹配相关的规则，则这些规则的方法需都执行毕，才能达到该元素的“结束”时刻。</li><br />
<li>finish(),解析结束时被调用，以提供给各个规则以清理临时数据的机会。</li></ol><br />
　　在设置digester时，通过调用addRule()方法，来注册一个特定的元素匹配模板以及相应的一个Rule类的实例。如上所述，Rule类中的事件处理方法，会在适当的时间被调用。这个机制，允许动态地生成Rule的实现。<br />
　　另外，digester也提供了一些处理常见情况的处理规则类。<br />
<ol><li>ObjectCreateRule,当begin()方法被调用时，这个规则类实例化一个指定的java类，并将其压入栈顶。这个被实例化的类的名字，默认是这个规则类构造函数得到的参数，也可以通过指定正在处理的xml元素的属性来传递一个新的类的名字。当end()方法被调用　时，栈顶的对象被弹出，Digester中对它的任何引用将被忽略。</li><br />
<li>FactoryCreateRule,一个非常有用的ObjectCreateRule的变体。</li><br />
<li>SetPropertiesRule,当begin()方法被调用时，digester使用标准的Java Relection API来识别JavaBean的属性设置方法(setter method)，这些方法名称中包含属性（property）的名字，这些属性与XML元素的属性(attribute)匹配，于是这些方法被调用并将相应的属性值(attribute value)传给它们。这些自然的映射可以被重写。建议不要过度使用这项功能，在大多数情况下，使用标准的BeanInfo机制会更好。</li><br />
<li>SetPropertyRule,当begin()方法被调用时，digester调用栈顶对象的一个特定的属性设置方法(property setter)并传给它特定的值(property和值分别由两个attribute命名)。这对XML需要遵循一个指定的DTD时比较有用，你可以设置一个特别的属性(property)，虽然在指定DTD没有attribute与其相对应。</li><br />
<li>SetNextRule,当end()方法被调用时，digester分析第二栈顶元素，寻找一个特定属性(property)的设置方法(setter method)，并接着调用这个方法，以栈顶的元素作参数。这个规则通常用来在两个对象间建立1对多的关系，所用的方法也常被叫做addChild什么的。</li><br />
<li>SetTopRule,当end()方法被调用时，digester分析栈顶元素，寻找一个特定属性(property)的设置方法(setter method)，并接着调用这个方法，以第二栈顶的元素作参数。这个规则通常用来在两个对象间建立1对多的关系，所用的方法也常被叫做setParent什么的。</li><br />
<li>CallMethodRule,这个规则设置当end()被调用时执行的栈顶对象的自定义方法，通过对这个规则的设置，来指定方法的名字、参数的数量以及定义的参数类型的Java类的名字。实际的参数值，来自激活这个方法的元素的子元素。</li><br />
<li>CallParamRule,这个规则用来指定CallMethodRule的参数的值的来源，它可以来自一个特定的属性，或子元素的body的内容.</li><br />
<li>NodeCreateRule,一个特殊的规则，将对象树的一部分转换成一个DOM结点(Node)，并压入栈顶。</li></ol><br />
　　对这些标准的规则类，可以创建它们的实例，并调用digester.addRule来注册它们。由于经常使用它们，所以digester定义了一些简便的方法来注册它们。如：<div class="code">Rule rule = new SetNextRule(digester, "addChild","com.mycompany.mypackage.MyChildClass");<br />
digester.addRule("a/b/c", rule);</div>可以用下列代码替换<div class="code">digester.addSetNext("a/b/c", "addChild",                        "com.mycompany.mypackage.MyChildClass");</div><br />
</p>

<span class="posted">Posted by Hilton at October 23, 2003 11:26 PM
| <a href="mt-tb.cgi-__mode=view&entry_id=333.htm" tppabs="http://hedong.3322.org/mt/mt-tb.cgi?__mode=view&entry_id=333" onclick="OpenTrackback(this.href); return false">TrackBack</a>

<br /></span>

</div>


<div class="comments-head"><a name="comments"></a>Comments</div>




<div class="comments-head">Post a comment</div>

<div class="comments-body">
<form method="post" action="http://hedong.3322.org/mt/mt-comments.cgi" name="comments_form" onsubmit="if (this.bakecookie[0].checked) rememberMe(this)">
<input type="hidden" name="static" value="1" />
<input type="hidden" name="entry_id" value="333" />

<div style="width:180px; padding-right:15px; margin-right:15px; float:left; text-align:left; border-right:1px dotted #bbb;">
	<label for="author">Name:</label><br />
	<input tabindex="1" id="author" name="author" /><br /><br />

	<label for="email">Email Address:</label><br />
	<input tabindex="2" id="email" name="email" /><br /><br />

	<label for="url">URL:</label><br />
	<input tabindex="3" id="url" name="url" /><br /><br />
</div>

Remember personal info?<br />
<input type="radio" id="bakecookie" name="bakecookie" /><label for="bakecookie">Yes</label><input type="radio" id="forget" name="bakecookie" onclick="forgetMe(this.form)" value="Forget Info" style="margin-left: 15px;" /><label for="forget">No</label><br style="clear: both;" />

<label for="text">Comments:</label><br />
<textarea tabindex="4" id="text" name="text" rows="10" cols="50"></textarea><br /><br />

<input type="submit" name="preview" value="&nbsp;Preview&nbsp;" />
<input style="font-weight: bold;" type="submit" name="post" value="&nbsp;Post&nbsp;" /><br /><br />

</form>

<script type="text/javascript" language="javascript">
<!--
document.comments_form.email.value = getCookie("mtcmtmail");
document.comments_form.author.value = getCookie("mtcmtauth");
document.comments_form.url.value = getCookie("mtcmthome");
if (getCookie("mtcmtauth")) {
    document.comments_form.bakecookie[0].checked = true;
} else {
    document.comments_form.bakecookie[1].checked = true;
}
//-->
</script>
</div>


</div>
</div>
</body>
</html>
	
